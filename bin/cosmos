#!/usr/bin/env ruby
# encoding: ascii-8bit

# Copyright 2014 Ball Aerospace & Technologies Corp.
# All Rights Reserved.
#
# This program is free software; you can modify and/or redistribute it
# under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 3 with
# attribution addendums as found in the LICENSE.txt

# This file will handle COSMOS tasks such as instantiating a new project

require 'cosmos'
require 'cosmos/tools/cmd_tlm_server/cmd_tlm_server_config'
require 'zip'
require 'zip/filesystem'
require 'fileutils'
require 'find'
require 'aws-sdk-s3'
require 'json'
require 'redis'

Aws.config.update(
  endpoint: 'http://localhost:9000',
  access_key_id: 'minioadmin',
  secret_access_key: 'minioadmin',
  force_path_style: true,
  region: 'us-east-1'
)

# Prints the usage text for the cosmos executable
def print_usage
  puts "Usage:"
  puts "  cosmos help                   # Displays this information"
  puts "  cosmos load                   # Loads a COSMOS user directory onto the cluster"
  puts "  cosmos install directory_name # Creates a barebones COSMOS user directory"
  puts "  cosmos demo directory_name    # Creates a demo COSMOS user directory"
  puts "  cosmos docs                   # Launches the documentation server"
  puts "  cosmos generate target <NAME> # Generate a COSMOS target"
  puts ""
  puts "Other Tools included with COSMOS:"
  puts "  rubysloc                      # Counts Ruby SLOC recursively"
  puts "  cstol_converter               # Converts all *.prc files recursively to COSMOS"
  puts ""
end

def install(install_type, install_folder)
  dir_name = ARGV[1]
  unless dir_name.nil?
    puts "Attempting COSMOS #{install_type} Installation to: #{dir_name}"

    #Determine if directory exists
    unless File.directory?(dir_name)
      #Create Directory
      FileUtils.makedirs(dir_name, {:verbose => true})

      #Copy files from gem install directory into new project
      FileUtils.cp_r(File.join(::Cosmos::PATH, install_folder, '.'), dir_name, {:verbose => true})

      puts "Complete"
    else
      puts "ERROR: Directory #{dir_name} already exists... aborting"
    end
  else
    puts "ERROR: Directory must be given to install to"
  end
end

def gen_tgt(target)
  %Q(# If you have custom limits responses or conversions you require them here
#REQUIRE #{target}_limits_response.rb
#REQUIRE #{target}_conversion.rb

# Ignored Parameters
# (parameters you don't want to see by default in various tools)
IGNORE_PARAMETER ID

# Ignored Items
# (items you don't want to see by default in various tools)
IGNORE_ITEM ID

# You can explicitly define the command and telemetry files
# you want to process and the order they are processed.
# If not then all files in cmd_tlm are processed in alphabetical order
#COMMANDS cmd.txt
#TELEMETRY tlm.txt
)
end

def gen_int(target)
  %Q(# This is a segment of the main config/tools/cmd_tlm_server/cmd_tlm_server.txt
# that will be used when that files specifies AUTO_INTERFACE_TARGETS or INTERFACE_TARGET #{target}.

# Modify this according to your actual target connection
# Please see the COSMOS Interface Configuration documentation

INTERFACE #{target}_INT tcpip_client_interface.rb localhost 8080 8081 10.0 nil BURST 4 0xDEADBEEF
  TARGET #{target}
)
end

def gen_cmd(target)
  %Q(COMMAND #{target} COMMAND BIG_ENDIAN "Packet description"
  # Keyword           Name  BitSize Type   Min Max  Default  Description
  APPEND_ID_PARAMETER ID    16      INT    1   1    1        "Identifier"
  APPEND_PARAMETER    VALUE 32      FLOAT  0   10.5 2.5      "Value"
  APPEND_PARAMETER    BOOL  8       UINT   MIN MAX  0        "Boolean"
    STATE FALSE 0
    STATE TRUE 1
  APPEND_PARAMETER    LABEL 0       STRING          "COSMOS" "The label to apply"
)
end

def gen_tlm(target)
  %Q(TELEMETRY #{target} STATUS BIG_ENDIAN "Telemetry description"
  # Keyword      Name  BitSize Type   ID Description
  APPEND_ID_ITEM ID    16      INT    1  "Identifier"
  APPEND_ITEM    VALUE 32      FLOAT     "Value"
  APPEND_ITEM    BOOL  8       UINT      "Boolean"
    STATE FALSE 0
    STATE TRUE 1
  APPEND_ITEM    LABEL 0       STRING    "The label to apply"
)
end

def gen_lib(target)
  %Q(# This class can be used in your scripts like so:
#   require '#{target.downcase}'
#   #{target.downcase} = #{target.capitalize}.new
#   #{target.downcase}.utility
# For more information see the COSMOS scripting guide

class #{target.capitalize}
  def utility
  end
end
)
end

def gen_proc(target)
  %Q(# Script Runner test script
cmd("#{target} COMMAND")
wait_check("#{target} STATUS BOOL == 'FALSE'", 5)
)
end

def gen_test(target)
  %Q(# To add this test to Test Runner edit config/tools/test_runner/test_runner.txt
# Add this line:
#   LOAD_UTILITY '#{target.downcase}_test'
#
# Test Runner test script
class #{target.capitalize}Test < Cosmos::Test
  # def setup
  #   # Implement group level setup
  # end

  def test_command
    cmd("#{target} COMMAND")
    wait_check("#{target} STATUS BOOL == 'FALSE'", 5)
  end

  # def teardown
  #   # Implement group level teardown
  # end
end

class #{target.capitalize}Suite < Cosmos::TestSuite
  # def setup
  #   # Implement suite level setup
  # end

  def initialize
    super()
    add_test('#{target.capitalize}Test')
  end

  # def teardown
  #   # Implement suite level teardown
  # end
end
)
end

def gen_screen(target)
  %Q(SCREEN AUTO AUTO 1.0

TITLE "Status"

VERTICALBOX
  SECTIONHEADER "Information"
  LABELVALUE #{target} STATUS VALUE
  LABELVALUE #{target} STATUS BOOL
END
)
end

def generate(args)
  case args[0]
  when 'target'
    unless File.exist?('./config/targets/')
      puts "generator must be run at the root of the COSMOS user installation"
      return
    end
    if args.length != 2
      puts "Usage: cosmos generate target <NAME>"
      return
    end
    target = args[1].upcase
    target_path = File.join("./config/targets/#{target}")
    if File.exist?(target_path)
      puts "Warning! Target #{target} already exists! Completely DELETE existing target? (N/y)"
      STDOUT.flush # Output the warning
      name = STDIN.gets.chomp
      if name != 'y'
        puts "Aborting generator"
        return
      end
      FileUtils.rm_rf target_path
      sleep 1 # Allow the delete to occur
    end
    FileUtils.mkdir(target_path)
    File.open(File.join(target_path, 'target.txt'), 'w') { |file| file.write(gen_tgt(target)) }
    File.open(File.join(target_path, 'cmd_tlm_server.txt'), 'w') { |file| file.write(gen_int(target)) }
    FileUtils.mkdir(File.join(target_path, 'cmd_tlm'))
    File.open(File.join(target_path, 'cmd_tlm', 'cmd.txt'), 'w') { |file| file.write(gen_cmd(target)) }
    File.open(File.join(target_path, 'cmd_tlm', 'tlm.txt'), 'w') { |file| file.write(gen_tlm(target)) }
    FileUtils.mkdir(File.join(target_path, 'lib'))
    File.open(File.join(target_path, 'lib', "#{target.downcase}.rb"), 'w') { |file| file.write(gen_lib(target)) }
    FileUtils.mkdir(File.join(target_path, 'procedures'))
    File.open(File.join(target_path, 'procedures', "#{target.downcase}_script.rb"), 'w') { |file| file.write(gen_proc(target)) }
    File.open(File.join(target_path, 'procedures', "#{target.downcase}_test.rb"), 'w') { |file| file.write(gen_test(target)) }
    FileUtils.mkdir(File.join(target_path, 'screens'))
    File.open(File.join(target_path, 'screens', "status.txt"), 'w') { |file| file.write(gen_screen(target)) }

    puts "Target #{target} successfully generated!\n"
    puts "Edit config/system/system.txt add add the line 'DECLARE_TARGET #{target}'"
# AUTO_INTERFACE_TARGETS # Use cmd_tlm_server.txt from all targets declared in system.txt
    puts "You may also have to edit your config/tools/cmd_tlm_server/cmd_tlm_server.txt"
    puts "and interface the target unless you're using AUTO_INTERFACE_TARGETS."
    puts "See the COSMOS System Configuration documentation for more details.\n"
  else # Unknown generator
    puts "Unknown generator #{args[0]}"
  end
end

def limits_change_callback(packet, item, old_limits_state, value, log_change)
  if log_change
    # Write to Server Messages that limits state has changed
    tgt_pkt_item_str = "#{packet.target_name} #{packet.packet_name} #{item.name} = #{value} is"
    packet_time = packet.packet_time
    pkt_time_str = ""
    pkt_time_str << " (#{packet.packet_time.sys.formatted})" if packet_time
    case item.limits.state
    when :BLUE
      Cosmos::Logger.info "#{tgt_pkt_item_str} #{item.limits.state}#{pkt_time_str}"
    when :GREEN, :GREEN_LOW, :GREEN_HIGH
      Cosmos::Logger.info "#{tgt_pkt_item_str} #{item.limits.state}#{pkt_time_str}"
    when :YELLOW, :YELLOW_LOW, :YELLOW_HIGH
      Cosmos::Logger.warn "#{tgt_pkt_item_str} #{item.limits.state}#{pkt_time_str}"
    when :RED, :RED_LOW, :RED_HIGH
      Cosmos::Logger.error "#{tgt_pkt_item_str} #{item.limits.state}#{pkt_time_str}"
    else
      Cosmos::Logger.error "#{tgt_pkt_item_str} UNKNOWN#{pkt_time_str}"
    end
  end
end

def check_limits(filenames)
  Cosmos::Logger.level = Cosmos::Logger::INFO
  packet_log_reader = Cosmos::System.default_packet_log_reader.new(*Cosmos::System.default_packet_log_reader_params)
  filenames.each do |filename|
    packet_log_reader.open(filename)
    Cosmos::System.telemetry.limits_change_callback = method(:limits_change_callback)
    packet_log_reader.each(filename) do |packet|
      packet.check_limits
    end
  end
end

# A helper method to make the zip writing recursion work
def write_zip_entries(base_dir, entries, zip_path, io)
  io.add(zip_path, base_dir) # Add the directory whether it has entries or not
  entries.each do |e|
    zip_file_path = File.join(zip_path, e)
    disk_file_path = File.join(base_dir, e)
    if File.directory? disk_file_path
      recursively_deflate_directory(disk_file_path, io, zip_file_path)
    else
      put_into_archive(disk_file_path, io, zip_file_path)
    end
  end
end

def recursively_deflate_directory(disk_file_path, io, zip_file_path)
  io.add(zip_file_path, disk_file_path)
  write_zip_entries(disk_file_path, entries, zip_file_path, io)
end

def put_into_archive(disk_file_path, io, zip_file_path)
  io.get_output_stream(zip_file_path) do |f|
    data = nil
    File.open(disk_file_path, 'rb') { |file| data = file.read }
    f.write(data)
  end
end

def load_cosmos(system_filename = nil, cmd_tlm_server_filename = nil)
  system_filename ||= 'system.txt'
  system_path = File.join(Dir.pwd, 'config', 'system', system_filename)
  system_config = Cosmos::SystemConfig.new(system_path)
  cmd_tlm_server_filename ||= 'cmd_tlm_server.txt'
  cmd_tlm_server_path = File.join(Dir.pwd, 'config', 'tools', 'cmd_tlm_server', cmd_tlm_server_filename)
  cmd_tlm_server_config = Cosmos::CmdTlmServerConfig.new(cmd_tlm_server_path, system_config)

  rubys3_client = Aws::S3::Client.new

  # Ensure targets bucket exists
  begin
    rubys3_client.head_bucket(bucket: 'targets')
  rescue Aws::S3::Errors::NotFound
    rubys3_client.create_bucket(bucket: 'targets')
  end

  # Hash, zip, and upload each target as necessary
  zip_targets = {}
  system_config.targets.each do |target_name, target|
    # Only do each original_name once
    hash = zip_targets[target.original_name]
    if hash
      target.id = hash
      next
    end

    # Build target file list
    target_files = []
    Find.find(target.dir) { |file| target_files << file }
    target_files.sort!
    hash = Cosmos.hash_files(target_files, nil, 'SHA256').hexdigest
    target.id = hash

    # Check if target config exists in S3
    s3_key = "#{target.original_name}/#{hash}.zip"
    found = true
    begin
      rubys3_client.head_object(bucket: 'targets', key: s3_key)
    rescue Aws::S3::Errors::NotFound
      found = false
    end

    unless found
      prefix = File.dirname(target.dir) + '/'
      output_file = File.join(Dir.tmpdir, hash + '.zip')
      File.delete(output_file) if File.exist?(output_file)
      unless File.exist?(output_file)
        Zip.continue_on_exists_proc = true
        Zip::File.open(output_file, Zip::File::CREATE) do |zipfile|
          target_files.each do |target_file|
            zip_file_path = target_file.delete_prefix(prefix)
            if File.directory?(target_file)
              zipfile.mkdir(zip_file_path)
            else
              zipfile.add(zip_file_path, target_file)
            end
          end
        end
      end

      # Write to S3 Bucket
      File.open(output_file, 'rb') do |file|
        rubys3_client.put_object(bucket: 'targets', key: s3_key, body: file)
      end

      puts "targets/#{s3_key} written to S3"
    end

    zip_targets[target.original_name] = hash
  end

  target_list = []
  target_names = []
  system_config.targets.each do |target_name, target|
    original_name = nil
    original_name = target.original_name if target.name != target.original_name
    target_filename = nil
    target_filename = File.basename(target.filename) if target.filename
    target_list << { 'target_name' => target_name, 'original_name' => original_name, 'target_filename' => target_filename, 'target_id' => target.id }
    target_names << target_name
  end
  target_config_dir = File.join(Dir.pwd, 'config', 'targets')
  Cosmos::System.instance(target_list, target_config_dir)

  redis = Redis.new(url: "redis://localhost:6379/0")

  # Save configuration to redis
  redis.del("cosmos_system")
  redis.hset('cosmos_system', 'limits_set', 'DEFAULT') # Current
  redis.hset('cosmos_system', 'limits_sets', JSON.generate(['DEFAULT'])) # Array of possible sets
  redis.hset('cosmos_system', 'target_names', JSON.generate(target_names))
  Cosmos::System.telemetry.all.each do |target_name, packets|
    redis.del("cosmostlm__#{target_name}")
    packets.each do |packet_name, packet|
      puts "Configuring tlm packet: #{target_name} #{packet_name}"
      redis.hset("cosmostlm__#{target_name}", packet_name, JSON.generate(packet.as_json))
    end
  end
  Cosmos::System.commands.all.each do |target_name, packets|
    redis.del("cosmoscmd__#{target_name}")
    packets.each do |packet_name, packet|
      puts "Configuring cmd packet: #{target_name} #{packet_name}"
      redis.hset("cosmoscmd__#{target_name}", packet_name, JSON.generate(packet.as_json))
    end
  end

  # Configure microservices
  # TODO: Need to only clear out old microservices that are unneeded for the current PROGRAM
  # For now just clear them all
  redis.del('cosmos_microservices')

  cmd_tlm_server_config.interfaces.each do |interface_name, interface|
    # Configure InterfaceMicroservice
    target_list = []
    interface.target_names.each do |target_name|
      target = system_config.targets[target_name]
      original_name = nil
      original_name = target.original_name if target.name != target.original_name
      target_filename = nil
      target_filename = File.basename(target.filename) if target.filename
      target_list << { 'target_name' => target_name, 'original_name' => original_name, 'target_filename' => target_filename, 'target_id' => target.id }
    end
    config = { 'filename' => "interface_microservice.rb", 'interface_params' => interface.config_params, 'target_list' => target_list }
    redis.hset('cosmos_microservices', "INTERFACE__#{interface_name}", JSON.generate(config))
    puts "Configured microservice INTERFACE__#{interface_name}"

    # Configure DecomMicroservice
    packet_topic_list = []
    interface.target_names.each do |target_name|
      begin
        Cosmos::System.telemetry.packets(target_name).each do |packet_name, packet|
          packet_topic_list << "PACKET__#{target_name}__#{packet_name}"
        end
      rescue
        # No telemetry packets for this target
      end
    end
    next unless packet_topic_list.length > 0

    config = { 'filename' => "decom_microservice.rb", 'target_list' => target_list, 'topics' => packet_topic_list }
    redis.hset('cosmos_microservices', "DECOM__#{interface_name}", JSON.generate(config))
    puts "Configured microservice DECOM__#{interface_name}"

    # Configure CvtMicroservice
    decom_topic_list = []
    interface.target_names.each do |target_name|
      begin
        Cosmos::System.telemetry.packets(target_name).each do |packet_name, packet|
          decom_topic_list << "DECOM__#{target_name}__#{packet_name}"
        end
      rescue
        # No telemetry packets for this target
      end
    end
    config = { 'filename' => "cvt_microservice.rb", 'topics' => decom_topic_list }
    redis.hset('cosmos_microservices', "CVT__#{interface_name}", JSON.generate(config))
    puts "Configured microservice CVT__#{interface_name}"

    # Configure PacketLogMicroservice
    config = { 'filename' => "packet_log_microservice.rb", 'topics' => packet_topic_list }
    redis.hset('cosmos_microservices', "PACKETLOG__#{interface_name}", JSON.generate(config))
    puts "Configured microservice PACKETLOG__#{interface_name}"

    # Configure DecomLogMicroservice
    config = { 'filename' => "decom_log_microservice.rb", 'topics' => decom_topic_list }
    redis.hset('cosmos_microservices', "DECOMLOG__#{interface_name}", JSON.generate(config))
    puts "Configured microservice DECOMLOG__#{interface_name}"
  end
end

def get_redis_keys
  redis = Redis.new(url: "redis://localhost:6379/0")
  puts "\n--- COSMOS Redis database keys ---"
  cursor = 0
  keys = []
  loop do
    cursor, result = redis.scan(cursor)
    keys.concat(result)
    cursor = cursor.to_i # cursor is returned as a string
    break if cursor == 0
  end
  keys.uniq!
  keys.sort!
  keys.select {|item| !item[/^tlm__/] }.each do |key|
    begin
      puts "#{key}\n  #{redis.hkeys(key)}"
    rescue Redis::CommandError
      # CommandError is raised if you try to hkeys on a stream
      puts "Stream: #{key}\n  #{redis.xinfo(:stream, key)}"
    end
  end
  puts "Packets Defs: #{keys.select{|item| item[/^tlm__/]}}"
end

if not ARGV[0].nil? # argument(s) given

  Cosmos::Logger.stdout = true

  # Handle each task
  case ARGV[0].downcase
  when 'load'
    load_cosmos(ARGV[1], ARGV[2])

  when 'docs'
    thread = Thread.new do
      system('yard server --gems')
    end
    sleep 3
    Cosmos.open_in_web_browser('http://localhost:8808/docs/cosmos/frames')
    thread.join

  when 'install'
    # Create a COSMOS barebones user directory
    install('', 'install')

  when 'demo'
    # Create a COSMOS demo user directory
    install('Demo', 'demo')

  when 'generate'
    generate(ARGV[1..-1])

  when 'check_limits'
    check_limits(ARGV[1..-1])

  when 'help'
    print_usage()

  when 'redis'
    # case(ARGV[1])
    # when 'keys'
    get_redis_keys()
    # else
    #   puts "Unknown redis task: #{ARGV[1]}\n"
    #   puts "Valid redis tasks: keys"
    # end

  else # Unknown task
    puts "Unknown task: #{ARGV[0]}\n"
    print_usage()
  end

else # No arguments given
  print_usage()
end
